#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#include "../rng.h"
#include "../constants.h"

#define G_UNIFORM_INC_NV
#define G_UNIFORM_SET 0
#include "../global_uniforms.h"
#undef G_UNIFORM_SET
#undef G_UNIFORM_INC_NV

#define G_CACHE_SET 1
#include "../global_caches.h"
#undef G_CACHE_SET

#include "../shading.h"
#include "../payloads.h"
layout(location = PAYLOAD_IDX_GENERAL)  rayPayloadNV InitialPayload PAYLOAD_GENERAL;
layout(location = PAYLOAD_IDX_SHADOWED) rayPayloadNV bool           PAYLOAD_SHADOWED;

bool is_shadowed(vec3 origin) {
    PAYLOAD_SHADOWED = true;

    traceNV(
        UNI_TLAS,
        gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsSkipClosestHitShaderNV, 0xff,
        1, 0, 1,
        origin, 0.01, -UNI_SUN.direction, 200.0,
        PAYLOAD_IDX_SHADOWED
    );

    return PAYLOAD_SHADOWED;
}

vec3 sampleBrdfSpecular(
        in out uint seed,
        const vec3 origin,
        const vec3 N,
        float alpha,
        const vec3 V
    ) {
    const mat3 basis = construct_ONB_frisvad(N);

    vec3 H = sampleGGXVNDF(
           vec2(noise(seed), noise(seed)), alpha, V, basis);
    vec3 L = reflect(V, H);

    float NoV = max(0, dot(N, V));
    float NoL = max(0, dot(N, L));

    if (NoL > 0 && NoV > 0)
    {
        float G1_NoL = G1_GGX(alpha, NoL);
        L = normalize(L);
        traceNV(
            UNI_TLAS,
            gl_RayFlagsNoneNV, 0xff,
            0, 0, 0,
            origin, 0.01, L, 200.0,
            PAYLOAD_IDX_GENERAL
        );

        const vec3 F_V_L = fresnelSchlick(max(0, dot(V, L)));
        return vec3(sunIllum(N)) * PAYLOAD_GENERAL.illumination * F_V_L * G1_NoL;
    }

    return vec3(0);
}



/*
vec3 sampleBrdfSpecular(
        in out uint seed,
        const vec3 origin,
        const vec3 normal,
        float alpha,
        const vec3 V
    ) {

    mat3 basis = construct_ONB_frisvad(normal);
    const vec3 Ni = sampleGGXVNDF(
           vec2(noise(seed), noise(seed)), alpha, V, basis);

    // const vec3 Ni = sampleGGXVNDF(V, alpha, noise(seed), noise(seed));
    vec3 Li = normalize(reflect(V, Ni)); // FIXME: remove normalize
    const float NoLi = max(0, dot(normal, Li));
    if (NoLi == 0) {
        return vec3(0);
    }

    traceNV(
        UNI_TLAS,
        gl_RayFlagsNoneNV, 0xff,
        0, 0, 0,
        origin, 0.01, Li, 200.0,
        PAYLOAD_IDX_GENERAL
    );

    const float F_V_Li = fresnelSchlickSameMaterial(max(0, dot(V, Li)));
    const float G1_Li = G1_GGX(alpha, NoLi);

    // G2(V, Li)/G1(V) = G1(Li)*G1(V)/G1(V) simplifies to G1_Li
    return sunIllum(N) * F_V_Li * G1_Li;
}
*/

void main() {
    const ivec2 xy = ivec2(gl_LaunchIDNV.xy);
    float seed_f = imageLoad(CACHE_NOISE, xy).r * 1024.;
    uint seed = uint(seed_f);


    vec3 specular = vec3(0);
    vec3 normal = imageLoad(CACHE_NORMALS, xy).xyz;

    if (normal != vec3(0)) {
        const vec3 origin = imageLoad(CACHE_ORIGIN, xy).xyz;
        const vec3 V = normalize(vec3(UNI_CAMERA.origin.xyz) - origin);
        const vec3 mer = imageLoad(CACHE_ILLUM_COEFFS, xy).rgb;
        const float alpha = mer.b * mer.b;

        specular = sampleBrdfSpecular(
            seed,
            origin,
            normal,
            alpha,
            V
        );
    }

    imageStore(CACHE_PT_SPECULAR, xy, vec4(specular, 0.0));
}
