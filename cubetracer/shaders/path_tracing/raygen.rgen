#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#include "../rng.h"
#include "../constants.h"

#define G_UNIFORM_INC_NV
#define G_UNIFORM_SET 0
#include "../global_uniforms.h"
#undef G_UNIFORM_SET
#undef G_UNIFORM_INC_NV

#define G_CACHE_SET 1
#include "../global_caches.h"
#undef G_CACHE_SET

#include "../payloads.h"
layout(location = PAYLOAD_IDX_GENERAL)  rayPayloadNV InitialPayload PAYLOAD_GENERAL;
layout(location = PAYLOAD_IDX_SHADOWED) rayPayloadNV bool           PAYLOAD_SHADOWED;

vec3 generate_rnd_direction(vec3 normal, vec2 uv) {
    const vec3 dir_sphere = sample_cos_hemisphere(uv);
    const mat3 basis = construct_ONB_frisvad(normal);
    return normalize(basis * dir_sphere);
}

bool is_shadowed(vec3 origin) {
    PAYLOAD_SHADOWED = true;

    traceNV(
        UNI_TLAS,
        gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsSkipClosestHitShaderNV, 0xff,
        1, 0, 1,
        origin, 0, -UNI_SCENE.sunDirection, 200.0,
        PAYLOAD_IDX_SHADOWED
    );

    return PAYLOAD_SHADOWED;
}

const int N_SAMPLES = 1;
const int N_BOUNCES = 1;

void indirect_illum(const vec3 origin, const vec3 normal, const ivec2 xy, inout vec3 illum) {
    for (int i = 0; i < N_SAMPLES; i++) {
        vec3 bounces_illum = vec3(0);

        float bounce_contrib = 1.0;
        vec3 bounce_origin = origin;
        vec3 bounce_normal = normal;

        for (int j = 0; j < N_BOUNCES; j++) {
            const vec2 uv = vec2(
                noise(7*i + 9*j*(xy.x * bounce_normal.xz + bounce_normal.y + 7.0  * bounce_origin.xy)),
                noise(11*i + 17*j*(xy.y * bounce_normal.xy - bounce_normal.z + 29.0 * bounce_origin.xz))
            );

            const vec3 bounce_dir = generate_rnd_direction(bounce_normal, uv);

            // FIXME: should replace by correct formula
            bounce_contrib *= max(dot(bounce_normal, bounce_dir), 0.0);

            if (bounce_contrib <= C_PT_MIN_CONTRIB)
                break;

            traceNV(
                UNI_TLAS,
                gl_RayFlagsNoneNV, 0xff,
                0, 0, 2,
                bounce_origin, 0, bounce_dir, 200.0,
                PAYLOAD_IDX_GENERAL
            );

            bounce_normal = PAYLOAD_GENERAL.normal;
            bounce_origin = PAYLOAD_GENERAL.hit_position;

            if (!PAYLOAD_GENERAL.hit)
                break;

            if (is_shadowed(PAYLOAD_GENERAL.hit_position))
                continue;

            vec3 BRDF = PAYLOAD_GENERAL.illumination;

            // FIXME: multiply by BRDF (reflectance/PI)
            bounces_illum += BRDF * bounce_contrib;
        }

        illum += bounces_illum;
    }

    illum /= N_SAMPLES;
}

void main() {
    const ivec2 xy = ivec2(gl_LaunchIDNV.xy);

    vec3 normal = imageLoad(CACHE_NORMALS, xy).xyz;

    vec3 illum = vec3(0);

    if (normal != vec3(0)) {
        const vec3 origin = imageLoad(CACHE_ORIGIN, xy).xyz;
        indirect_illum(origin, normal, xy, illum);
    }

    imageStore(CACHE_PT_ILLUM, xy, vec4(illum, 0.0));
}
