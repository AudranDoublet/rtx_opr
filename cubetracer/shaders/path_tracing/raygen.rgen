#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#include "../rng.h"
#include "../constants.h"

#define G_UNIFORM_INC_NV
#define G_UNIFORM_SET 0
#include "../global_uniforms.h"
#undef G_UNIFORM_SET
#undef G_UNIFORM_INC_NV

#define G_CACHE_SET 1
#include "../global_caches.h"
#undef G_CACHE_SET

#include "../shading.h"
#include "../payloads.h"
layout(location = PAYLOAD_IDX_GENERAL)  rayPayloadNV InitialPayload PAYLOAD_GENERAL;
layout(location = PAYLOAD_IDX_SHADOWED) rayPayloadNV bool           PAYLOAD_SHADOWED;

bool is_shadowed(vec3 origin) {
    PAYLOAD_SHADOWED = true;

    traceNV(
        UNI_TLAS,
        gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsSkipClosestHitShaderNV, 0xff,
        1, 0, 1,
        origin, 0.01, -UNI_SUN.direction, 200.0,
        PAYLOAD_IDX_SHADOWED
    );

    return PAYLOAD_SHADOWED;
}


bool sampleBrdfDiffuseBounces(const vec2 rnd,
        inout vec3 origin,
        inout vec3 normal,
        inout vec3 diffuse,
        inout float throughput) {
    const vec3 direction = sampleCosHemisphere(normal, rnd);

    // FIXME: must replace by correct formula
    throughput *= max(dot(normal, direction), 0.0);

    traceNV(
        UNI_TLAS,
        gl_RayFlagsNoneNV, 0xff,
        0, 0, 2,
        origin, 0.01, direction, 200.0,
        PAYLOAD_IDX_GENERAL
    );

    if (!PAYLOAD_GENERAL.hit) {
        return false;
    }

    normal = PAYLOAD_GENERAL.normal;
    origin = PAYLOAD_GENERAL.hit_position;

    if (is_shadowed(origin))
        return true;

    // FIXME: must replace by correct formula (div by prob)

    vec3 BRDF = vec3(1);
    diffuse += 2.0 * BRDF * sunIllum(normal) * throughput;

    return true;
}

vec3 sampleBrdfDiffuse(inout uint seed, vec3 origin, vec3 normal, const uint n_bounces) {
    float throughput = 1.0;
    vec3 diffuse = vec3(0);

    for (uint i = 0; i < n_bounces; i++) {
        const vec2 rnd = vec2(
            noise(seed),
            noise(seed)
        );

        if (!sampleBrdfDiffuseBounces(rnd, origin, normal, diffuse, throughput)) {
            break;
        }
    }

    return diffuse;
}

vec3 ImportanceSampleGGX_VNDF(vec2 u, float alpha, vec3 V, mat3 basis)
{
    vec3 Ve = -vec3(dot(V, basis[0]), dot(V, basis[2]), dot(V, basis[1]));
    vec3 Vh = normalize(vec3(alpha * Ve.x, alpha * Ve.y, Ve.z));

    float lensq = Vh.x*Vh.x + Vh.y*Vh.y;
    vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) * inversesqrt(lensq) : vec3(1.0, 0.0, 0.0);
    vec3 T2 = cross(Vh, T1);

    float r = u.x;
    float phi = 2.0 * C_PI * u.y;
    float t1 = r * cos(phi);
    float t2 = r * sin(phi);
    float s = 0.5 * (1.0 + Vh.z);
    t2 = (1.0 - s) * sqrt(1.0 - t1*t1)+ s * t2;

    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1*t1 - t2*t2)) * Vh;

    // Tangent space H
    vec3 Ne = vec3(alpha * Nh.x, max(0.0, Nh.z), alpha * Nh.y);

    // World space H
    return normalize(basis * Ne);
}


vec3 sampleBrdfSpecular(
        in out uint seed,
        const vec3 origin,
        const vec3 normal,
        float alpha,
        const vec3 V
    ) {

    mat3 basis = construct_ONB_frisvad(normal);

    vec3 N = normal;

    vec3 H = ImportanceSampleGGX_VNDF(
           vec2(noise(seed), noise(seed)), alpha, V, basis);
    vec3 L = reflect(V, H);

    float NoV = max(0, dot(N, V));
    float NoL = max(0, dot(N, L));

    if (NoL > 0 && NoV > 0)
    {
        float G1_NoL = G1_GGX(alpha, NoL);
        L = normalize(L);
        traceNV(
            UNI_TLAS,
            gl_RayFlagsNoneNV, 0xff,
            0, 0, 0,
            origin, 0.01, L, 200.0,
            PAYLOAD_IDX_GENERAL
        );

        const float F_V_L = fresnelSchlick(max(0, dot(V, L)));
        return vec3(sunIllum(N)) * PAYLOAD_GENERAL.illumination * F_V_L * G1_NoL;
    }

    return vec3(0);
}



/*
vec3 sampleBrdfSpecular(
        in out uint seed,
        const vec3 origin,
        const vec3 normal,
        float alpha,
        const vec3 V
    ) {

    mat3 basis = construct_ONB_frisvad(normal);
    const vec3 Ni = ImportanceSampleGGX_VNDF(
           vec2(noise(seed), noise(seed)), alpha, V, basis);

    // const vec3 Ni = sampleGGXVNDF(V, alpha, noise(seed), noise(seed));
    vec3 Li = normalize(reflect(V, Ni)); // FIXME: remove normalize
    const float NoLi = max(0, dot(normal, Li));
    if (NoLi == 0) {
        return vec3(0);
    }

    traceNV(
        UNI_TLAS,
        gl_RayFlagsNoneNV, 0xff,
        0, 0, 0,
        origin, 0.01, Li, 200.0,
        PAYLOAD_IDX_GENERAL
    );

    const float F_V_Li = fresnelSchlickSameMaterial(max(0, dot(V, Li)));
    const float G1_Li = G1_GGX(alpha, NoLi);

    // G2(V, Li)/G1(V) = G1(Li)*G1(V)/G1(V) simplifies to G1_Li
    return sunIllum(N) * F_V_Li * G1_Li;
}
*/

const int N_BOUNCES_DIFFUSE  = 0;
const int N_SAMPLES_SPECULAR = 3;

void indirectLighting(
    inout uint seed, 
    const vec3 origin, 
    const vec3 normal, 
    const float alpha,
    inout vec3 illum) {
    vec3 diffuse = sampleBrdfDiffuse(seed, origin, normal, N_BOUNCES_DIFFUSE);

    vec3 specular = vec3(0);
    const vec3 V = normalize(vec3(UNI_CAMERA.origin.xyz) - origin);
    const float NoV = max(0, dot(normal, V));

    if (NoV != 0) {
        for (uint i = 0; i < N_SAMPLES_SPECULAR; i++) {
            specular += sampleBrdfSpecular(
                seed,
                origin,
                normal,
                alpha,
                V
            );
        }
        specular /= float(N_SAMPLES_SPECULAR);
    }

    // FIXME: should be diffuse * (1-fresnel) + specular
    // illum = diffuse + specular;
    illum = specular;
    // illum = diffuse;
}

void main() {
    const ivec2 xy = ivec2(gl_LaunchIDNV.xy);
    float seed_f = imageLoad(CACHE_NOISE, xy).r * 255.;
    uint seed = uint(seed_f);

    vec3 normal = imageLoad(CACHE_NORMALS, xy).xyz;

    vec3 illum = vec3(0);

    if (normal != vec3(0)) {
        const vec3 origin = imageLoad(CACHE_ORIGIN, xy).xyz;
        const vec3 mer = imageLoad(CACHE_ILLUM_COEFFS, xy).rgb;
        const float alpha = mer.b * mer.b;

        indirectLighting(
            seed,
            origin,
            normal,
            alpha,
            illum
        );
    }

    seed_f += 1.;
    if (seed_f > 255)
        seed_f = 0;

    imageStore(CACHE_NOISE, xy, vec4(seed_f / 255.0));
    imageStore(CACHE_PT_ILLUM, xy, vec4(illum, 0.0));
}
