#version 460

#extension GL_GOOGLE_include_directive : enable

#define G_UNIFORM_SET 0
#define G_CACHE_SET 1

#include "rng.h"
#include "global_uniforms.h"
#include "global_caches.h"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main() {
    const ivec2 xy = ivec2(gl_GlobalInvocationID.xy);

    if (UNI_SCENE.rendered_buffer == 0)
    {
        const vec4 direct_illum = imageLoad(CACHE_DIRECT_ILLUM, xy);
        const vec4 shadows = imageLoad(CACHE_SHADOWS, xy);
        const vec4 pt_illum = vec4(imageLoad(CACHE_PT_ILLUM, xy).xyz, 1.0);

        imageStore(CACHE_RESULT_IMAGE, xy, direct_illum * shadows + max(pt_illum, 0));
    }
    else if (UNI_SCENE.rendered_buffer == 1)
    {
        const vec4 normal = (imageLoad(CACHE_NORMALS, xy) + vec4(1.0)) / 2.0;
        imageStore(CACHE_RESULT_IMAGE, xy, normal / 2);
    }
    else if (UNI_SCENE.rendered_buffer == 2)
    {
        const vec4 pt_illum = vec4(imageLoad(CACHE_PT_ILLUM, xy).xyz, 1);
        imageStore(CACHE_RESULT_IMAGE, xy, pt_illum);
    }
    else if (UNI_SCENE.rendered_buffer == 3)
    {
        const vec4 direct_illum = imageLoad(CACHE_DIRECT_ILLUM, xy);
        const vec4 shadows = imageLoad(CACHE_SHADOWS, xy);

        imageStore(CACHE_RESULT_IMAGE, xy, direct_illum * shadows);
    }
    else if (UNI_SCENE.rendered_buffer == 4)
    {
        const vec4 shadows = imageLoad(CACHE_SHADOWS, xy);

        imageStore(CACHE_RESULT_IMAGE, xy, shadows);
    }
    else if (UNI_SCENE.rendered_buffer == 5)
    {
        vec3 origin = imageLoad(CACHE_ORIGIN, xy).xyz;
        vec3 normal = imageLoad(CACHE_NORMALS, xy).xyz;
        vec3 color = vec3(0);

        if (normal != vec3(0)) {

            origin /= vec3(16, 1, 16);
            origin = floor(origin);
            origin *= C_PI;

            uint seed = uint(origin.x) * 7 + uint(origin.z) * 11;

            float a = noise(seed);
            float b = noise(seed);

            color = vec3(a, b, 0.5+(cos(2*C_PI*origin.x) + sin(2*C_PI*origin.z))/4);
        }

        imageStore(CACHE_RESULT_IMAGE, xy, vec4(color, 0.0));
    }
    else if (UNI_SCENE.rendered_buffer == 6)
    {
        const vec4 shadows = vec4(imageLoad(CACHE_DENOISE_NEW_HISTORY_LENGTH, xy).r) / 32.0;

        imageStore(CACHE_RESULT_IMAGE, xy, shadows);
    }
    else if (UNI_SCENE.rendered_buffer == 7)
    {
        float noise = imageLoad(CACHE_NOISE, xy).r;
        imageStore(CACHE_RESULT_IMAGE, xy, vec4(noise));
    }
    else if (UNI_SCENE.rendered_buffer == 8)
    {
        vec2 xy_ratio = vec2(xy) / vec2(imageSize(CACHE_RESULT_IMAGE));
        ivec2 xy_scaled_shadow = ivec2(
            round(xy_ratio * vec2(imageSize(CACHE_SHADOW_MAP)))
        );

        vec4 shadow_map = imageLoad(CACHE_SHADOW_MAP, xy);
        //vec4 shadow_map = texture(CACHE_SHADOW_MAP_TEX, xy_ratio);
        imageStore(CACHE_RESULT_IMAGE, xy, vec4(min(shadow_map.w, 256.0) / 256.0));
        //imageStore(CACHE_RESULT_IMAGE, xy, shadow_map);
    }

    imageStore(CACHE_DENOISE_PREV_DIFFUSE, xy, imageLoad(CACHE_PT_ILLUM, xy));
    imageStore(CACHE_DENOISE_PREV_MOMENTS, xy, imageLoad(CACHE_DENOISE_NEW_MOMENTS, xy));
    imageStore(CACHE_DENOISE_PREV_HISTORY_LENGTH, xy, imageLoad(CACHE_DENOISE_NEW_HISTORY_LENGTH, xy));
    imageStore(CACHE_DENOISE_PREV_INITIAL_DISTANCES, xy, imageLoad(CACHE_INIT_DISTANCES, xy));
}
