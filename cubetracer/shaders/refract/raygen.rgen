#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#define G_UNIFORM_INC_NV
#define G_UNIFORM_SET 0
#include "../global_uniforms.h"
#undef G_UNIFORM_SET
#undef G_UNIFORM_INC_NV

#define G_CACHE_SET 1
#include "../global_caches.h"
#undef G_CACHE_SET

#include "../payloads.h"
#include "../shading.h"

layout(location = PAYLOAD_IDX_GENERAL) rayPayloadNV InitialPayload PAYLOAD_GENERAL;
layout(location = PAYLOAD_IDX_SHADOWED) rayPayloadNV bool          PAYLOAD_SHADOWED;

bool isShadowed(vec3 origin) {
    PAYLOAD_SHADOWED = true;

    traceNV(
        UNI_TLAS,
        gl_RayFlagsTerminateOnFirstHitNV | gl_RayFlagsSkipClosestHitShaderNV, 0xff,
        1, 0, 1,
        origin, 0.01, -UNI_SUN.direction, 200.0,
        PAYLOAD_IDX_SHADOWED
    );

    return PAYLOAD_SHADOWED;
}

float fresnelSchlick(vec3 N, vec3 I, float n1, float n2, float eta) {
    float F0 = (n1-n2) / (n1+n2);
    F0 *= F0;

    float cosX = -dot(N, I);
    if (n1 > n2) {
        float sinT2 = eta*eta*(1.0-cosX*cosX);
        // Total internal reflection
        if (sinT2 > 1.0)
            return 1.0;
        cosX = sqrt(1.0-sinT2);
    }

    float x = 1.0-cosX;
    return F0 + (1.0 - F0)*x*x*x*x*x;
}

float getMaterialIOR(uint material) {
    switch (material) {
        case 3:
            return 1.325;
        case 4:
            return 1.5;
    }
    return 1.0;
}

vec3 traceRefraction(inout vec3 origin, inout vec3 N, inout vec3 I,
        inout float n1, inout float n2, inout float throughput, out bool stop) {
    const float eta = n1/n2;

    vec3 direction = refract(I, N, eta);
    float reflectionCoeff = fresnelSchlick(N, I, n1, n2, eta);
    throughput *= (1 - reflectionCoeff);

    traceNV(
        UNI_TLAS,
        gl_RayFlagsNoneNV,
        0xff, 0, 0, 0,
        origin, 0.01, direction, 200.0,
        PAYLOAD_IDX_GENERAL
    );

    // SKY 
    if (!PAYLOAD_GENERAL.hit) {
        stop = true;
        return throughput * PAYLOAD_GENERAL.illumination;
    }

    float opacity = PAYLOAD_GENERAL.alpha;
    // OPAQUE MATERIAL
    if (opacity == 1.0) {
        stop = true;
        float shadow = isShadowed(PAYLOAD_GENERAL.hit_position) ? 0 : 1;
        return shadow * throughput *
            sunIllum(PAYLOAD_GENERAL.normal) * PAYLOAD_GENERAL.illumination;
    }

    const uint material = PAYLOAD_GENERAL.material;

    // FIXME: should compute color + update ior, normal, etc...
    // n1 = n2;
    // n2 = getMaterialIOR(material);
    // origin = PAYLOAD_GENERAL.hit_position;
    // N = PAYLOAD_GENERAL.normal;
    // I = direction;

    // refractionColor = sunIllum(N) * PAYLOAD_GENERAL.illumination;

    // FIXME: should test if continue or stop
    // FIXME: color scattering

    return vec3(1,0,0);
}

vec3 traceRefractions(vec3 origin, vec3 N, vec3 I, uint material) {
    float n1 = getMaterialIOR(0);
    float n2 = getMaterialIOR(material);

    vec3 refractColor = vec3(0);
    float throughput = 1.0;
    bool stop = false;

    for (uint i = 0; i < C_REFRACT_DEPTH_MAX 
            && throughput > C_REFRACT_MIN_CONTRIB
            && stop; i++) {

        refractColor += traceRefraction( origin, N, I, n1, n2, throughput, stop);
    }

    return refractColor;
}

void main() {
    const ivec2 xy = ivec2(gl_LaunchIDNV.xy);

    const float opacity = imageLoad(CACHE_BLOCK_COLOR, xy).a;
    if (imageLoad(CACHE_INIT_DISTANCES, xy).r == 0.0 || opacity == 1.0)
    {
        imageStore(CACHE_REFRACTION, xy, vec4(0));
        return;
    }

    const vec3 origin = imageLoad(CACHE_ORIGIN, xy).xyz;
    const vec3 N = imageLoad(CACHE_NORMALS, xy).xyz;
    const vec3 I = normalize(origin - vec3(UNI_CAMERA.origin.xyz));

    const vec4 merm = imageLoad(CACHE_ILLUM_COEFFS, xy);

    vec3 refractionContrib = traceRefractions(origin, N, I, uint(merm.w));
    refractionContrib *= (1 - opacity);

    imageStore(CACHE_REFRACTION, xy, vec4(1));
}
